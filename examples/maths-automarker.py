import json
from operator import itemgetter
from typing import TypedDict
from sympy.parsing.latex import parse_latex
from sympy import simplify, Integral

import requests
import typer


class MarkPayload(TypedDict):
    mark: float
    feedback: str


students_url = "/students"
questions_url = "/questions"


def lookup_key(*tokens):
    return "-".join(map(str, tokens))


def build_lookup_table(items):
    keys = lambda i: [k for k in ["question", "part", "section", "task"] if k in i]
    return {lookup_key(*itemgetter(*keys(i))(i)): i for i in items}


def make_request(url, method="get", params=None, data=None):
    res = getattr(requests, method)(url, params=params, data=data)
    if res.status_code == requests.codes.ok:
        return res.json()
    raise Exception(f"Request for '{url}' failed with status code {res.status_code}")


# ^ Helpers ^ ==========================================================================================
# You should not need to modify the above functions.

# Example of a question structure
# instructions: |
#       Calculus questions
#     i:
#       instructions: |
#         Consider the function $x^2$.
#       maximum mark: 30
#       tasks:
#       - instructions: |
#           Enter the integral.
#         type: maths single answer
#       - instructions: |
#           Enter the derivative.
#         type: maths single answer

maths_single_answer_marks = {
    "1-3-1-1": { "answer": "x^3/3 + C", "mark": 20},
    "1-3-1-2": { "answer": "2x", "mark": 10},
}


model_answer = r"\frac{\pi}{2} \tanh \frac{\pi}{2}"

class Automarker:
    def __init__(self, marks: dict[str, dict], answers: dict[str, dict]):
        self.marks = marks
        self.answers = answers

    def run(self, username: str, section_id: str, max_mark: int, tasks: list[dict]):
        if self.marks.get(section_id) is None:
            mark = 0
            has_maths_answer = False

            for t, task in enumerate(tasks, 1):
                if task["type"].startswith("MATHS_SINGLE_ANSWER"):
                    has_maths_answer = True
                    task_id = lookup_key(section_id, t)
                    answer = self.answers.get(task_id, {}).get("answer")
                    task_mark_and_answer = maths_single_answer_marks[task_id]
                    answer = json.loads(self.answers.get(task_id, {}).get("answer"))["latex"]
                    if task_mark_and_answer and answer:
                        expr1 = parse_latex(answer)
                        expr2 = parse_latex(task_mark_and_answer["answer"])

                        feedback = "Awarded designated marks for answer."
                        if (expr1.has(Integral)):
                            feedback = "Solution should not contain an integral"
                        elif (simplify(expr1 - expr2) == 0):
                            mark += task_mark_and_answer["mark"]
                            
            if has_maths_answer:
                mark = max(0, mark)
                mark = min(max_mark, mark)
                return {
                    "mark": mark,
                    "feedback": feedback,
                }


        return None


def main(
    root_url: str = typer.Argument(
        ...,
        help="Root URL of your answerbook exam e.g. http://answerbook.doc.ic.ac.uk/2023/60005/exam/api",
    ),
):
    questions = make_request(root_url + questions_url)
    students = make_request(root_url + students_url)
    for student in students:
        username = student["username"]
        marks_url = root_url + f"/{username}/marks"

        # Build lookup tables to find if
        # a mark already exists for the given student and a given question-part-section combination;
        # an answer exists for the given student and a given question-part-section-task combination
        mark_lookup = build_lookup_table(make_request(marks_url))
        ans_lookup = build_lookup_table(make_request(root_url + f"/{username}/answers"))
        automarker = Automarker(mark_lookup, ans_lookup)

        for q, question in questions.items():
            for p, parts in question["parts"].items():
                for s, section in parts["sections"].items():
                    section_id = lookup_key(q, p, s)
                    max_mark = section["maximum_mark"]
                    tasks = section["tasks"]
                    ###################################################################
                    # This is where the mark for the task is autogenerated.
                    # The output is a dict shaped as `MarkPayload` (above)
                    # that we then enrich with question, part and section for POSTing.
                    payload = automarker.run(username, section_id, max_mark, tasks)
                    ###################################################################
                    if payload is not None:
                        payload = {
                            **payload,
                            "question": q,
                            "part": p,
                            "section": s,
                        }

                        try:
                            make_request(marks_url, "post", data=json.dumps(payload))
                            print(f"mark saved for {username} on {section_id}")
                        except Exception:
                            print(f"mark not saved for {username} on {section_id}")


if __name__ == "__main__":
    typer.run(main)
